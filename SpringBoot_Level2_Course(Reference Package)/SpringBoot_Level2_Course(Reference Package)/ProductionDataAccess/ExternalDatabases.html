<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>External Database Integration</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>External Database Integration</h1>

<h2>Moving Beyond H2 Database</h2>
<p>In production environments, applications require robust, scalable database solutions. While H2 is excellent for development and testing, production applications typically use external relational databases like <strong>PostgreSQL</strong> or <strong>MySQL</strong>.</p>

<h2>Why External Databases?</h2>
<ul>
    <li><strong>Persistence:</strong> Data survives application restarts and deployments</li>
    <li><strong>Scalability:</strong> Better performance under high load</li>
    <li><strong>Reliability:</strong> Built-in backup, replication, and recovery features</li>
    <li><strong>Security:</strong> Advanced authentication and authorization mechanisms</li>
    <li><strong>Concurrent Access:</strong> Multiple application instances can share the same database</li>
</ul>

<h2>PostgreSQL Integration Steps</h2>

<h3>Step 1: Add PostgreSQL Dependency</h3>
<p>Replace or add alongside the H2 dependency in your <strong>pom.xml</strong> (Maven) or <strong>build.gradle</strong> (Gradle):</p>

<div class="code-block">
<pre><code>&lt;!-- Maven --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- Gradle --&gt;
runtimeOnly 'org.postgresql:postgresql'
</code></pre>
</div>

<h3>Step 2: Database Configuration</h3>
<p>Update your <strong>application.properties</strong> or <strong>application.yml</strong> file:</p>

<div class="code-block">
<pre><code># PostgreSQL Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/my_database
spring.datasource.username=db_user
spring.datasource.password=db_password
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA Configuration for PostgreSQL
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=false
</code></pre>
</div>

<h2>Configuration Properties Explained</h2>
<table>
    <tr>
        <th>Property</th>
        <th>Purpose</th>
        <th>Production Value</th>
    </tr>
    <tr>
        <td class="rowheader">spring.datasource.url</td>
        <td>Database connection URL</td>
        <td>Points to external PostgreSQL server</td>
    </tr>
    <tr>
        <td class="rowheader">spring.datasource.username</td>
        <td>Database user credentials</td>
        <td>Application-specific database user</td>
    </tr>
    <tr>
        <td class="rowheader">spring.jpa.hibernate.ddl-auto</td>
        <td>Schema management strategy</td>
        <td>validate (never create/update in production)</td>
    </tr>
    <tr>
        <td class="rowheader">spring.jpa.show-sql</td>
        <td>SQL logging control</td>
        <td>false (avoid performance impact)</td>
    </tr>
</table>

<h2>MySQL Integration Alternative</h2>
<p>For MySQL databases, use these configurations:</p>

<div class="code-block">
<pre><code># MySQL Dependency (Maven)
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;

# MySQL Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/my_database
spring.datasource.username=db_user
spring.datasource.password=db_password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
</code></pre>
</div>

<h2>Connection Pool Configuration</h2>
<p>For production applications, configure connection pooling for optimal performance:</p>

<div class="code-block">
<pre><code># HikariCP Configuration (Spring Boot default)
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000
spring.datasource.hikari.connection-timeout=30000
</code></pre>
</div>

<h2>Security Best Practices</h2>
<ul>
    <li><strong>Environment Variables:</strong> Never hardcode credentials in configuration files</li>
    <li><strong>Least Privilege:</strong> Create database users with minimal required permissions</li>
    <li><strong>SSL/TLS:</strong> Enable encrypted connections to the database</li>
    <li><strong>Network Security:</strong> Restrict database access to application servers only</li>
</ul>

<h2>Common Migration Issues</h2>
<h3>Schema Differences</h3>
<p>Different databases have varying SQL dialects and data types. Common issues include:</p>
<ul>
    <li><strong>Auto-increment columns:</strong> SERIAL (PostgreSQL) vs AUTO_INCREMENT (MySQL)</li>
    <li><strong>Boolean types:</strong> BOOLEAN (PostgreSQL) vs TINYINT(1) (MySQL)</li>
    <li><strong>Text fields:</strong> TEXT vs VARCHAR length limits</li>
</ul>

<h3>Testing Strategy</h3>
<p>Maintain separate configurations for testing:</p>
<ul>
    <li>Use H2 for unit tests (fast, isolated)</li>
    <li>Use Testcontainers for integration tests (real database)</li>
    <li>Test against production database type in staging environment</li>
</ul>

<script type="text/javascript">
// No promotional content
</script>
</body>
</html>